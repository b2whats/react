'use strict';

var _ = require('underscore');
var Q = require('q');
//Q.longStackSupport = true; //сильно упрощает сообщения про ошибок, сильно тормозит Q (в десять и более раз)

/** Дополнения к Q
 * 1) Promise.seq_map(function_cb(x, index)) 
 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, 
 * or is rejected with the same rejection reason as the first promise to be rejected.
 * instead of all, calls function_cb on each fulfilled promise, and map fulfilled result to out promise
 * sample:
 *   a) Q([1,2,3,4]).sequential(function(x){return some_promise(x);}).then(function(xx){});//xx array contains fulfilled (resolved) promises values of some_promise(x)
 *   b) Q([promise(1),promise(2),promise(3),promise(4)]).sequential(function(x){return x;}).then(function(xx){});
 * and
 * 2) seq_map_pertick
 * same as seq_map but runs every callback in next tick
 * 
 * ДЛЯ ЧЕГО НУЖНЫ.
 * 1) seq_map нужен когда надо последовательно выполнить какой либо объем работ, например опросить базу, считать значения, обработать
 * 2) seq_map_pertick нужен для выполнения longrunningtask дабы не останавливать очередь обработки событий.
 */


module.exports = (function(){
  var sequential_each = function(arr, fn){
    /*jshint newcap:false*/
    var prom = Q([]);
    var fn_promised = Q.promised(fn);
    
    _.each(arr, function(a, index){
      prom = prom.then(function(prev_res){
        if(Q.isPromise(a)){
            return fn_promised(a, index, prev_res)
              .then(function(result){
                prev_res.push(result);
                return prev_res;
              });
          }else{
            var result = fn(a, index, prev_res);
            if(Q.isPromise(result)){
              return result.then(function(res){
                prev_res.push(res);
                return prev_res;
              });
            }else
            {
              prev_res.push(result);
              return prev_res;
            }
          }
      });
    });
    return prom;
  };

  var next_tick_nodified = function(fn_2_call, callback){
    setImmediate(function(){
      try{
        callback(null, fn_2_call());
      }catch(e){
        callback(e);
      }
    });
  };

  var next_tick = function(fn){
    return function(){
      return Q.denodeify(next_tick_nodified, fn.bind.apply(fn, [null].concat(Array.prototype.slice.call(arguments))))();
    };
  };

  Q.makePromise.prototype.seq_map = function (fn) {
    /*jshint newcap:false*/
    return Q(this).then(function(res){
      return sequential_each(res, fn);
    });
  };


  Q.makePromise.prototype.seq_map_pertick = function (fn) {
    /*jshint newcap:false*/
    return Q(this).then(function(res){
      return sequential_each(res, next_tick(fn));
    });
  };

  return Q;
})();
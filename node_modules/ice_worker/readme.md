
Основная идея - 
  Распаралелить долгоиграющие задачи

Как работает:
  Задачи запускаются в отдельных node процессах, и ice_worker позволяет
  вызывать их там из любого количества других node процессов 
  Механизм рапределения нагрузки использует смесь round robin алгоритма с алгоритмом 
  подтверждения выполнения задачи и регулируется парамером prefetchCount,
  (если prefetchCount=1 то задача не будет отправлена в процесс пока процесс не выполнит текущую задачу,
   если prefetchCount=N   N>1 то пока в процессах количество выполняемых одновременно задач меньше N используется roundrobin)

Терминология:
  worker - задача выполняемая в отдельных процессах   



Как использовать.
Пример worker:
----------------------------------
'use strict';
var ice_worker = require('ice_worker');
var q = require('ice_q');

ice_worker.register_worker('hello', {prefetchCount:1}, 
  function(a,b,c){
    return [a+1,b+1,c+1];
  });
-----------------------------------

Пример вызова worker
------------------------------------
ice_worker.call_worker('hello', 1, 2, 3)
.then(function(worker_result){
  console.log(worker_result); //выведет [2,3,4]
});
------------------------------------
    
worker может быть асинхронным и возвращать promise
см пример: tests/worker_2.js

worker может ответить - что он не готов обрабатывать задачу и хочет чтобы ее обработал следующий worker в очереди
см пример: tests/worker_pass.js
такой механизм необходим например когда требуется обновлять данные live т/е без периодов когда сервер недоступен или не работает
пример:
запущено два worker пришло время обновить данные, один из воркеров уходит в режим всегда возвращать kPASS_TO_OTHER_WORKER и начинает обновлять
данные, в момент когда данные обновлены он сообщает второму worker что тот должен обновиться а сам начинает возвращать данные как и положено

Внутренняя кухня:
Протокол для передачи выбран rabbitMq
Для распределения нагрузки и тп тоже используется rabbitMq протокол
Кратко
Каждый worker создает или подписывается на уже существующую очередь вида
ns + '.' + worker_name отсюда все worker с одинаковыми именами используют одну очередь

Каждый runner - вызыватель worker передает при вызове дпополнительные параметры (см rabbitMq) а именно
replyTo и correlationId

Получив данные и обработав их воркер отсылает результат в очередь с именем переданным в параметре 
replyTo и возвращает параметр correlationId равный полученному

Что позволяет четко понимать кто вызвал worker и куда вернуть результат
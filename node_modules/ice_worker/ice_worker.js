'use strict';
var amqp = require('amqp');
var q = require('ice_q');
var _ = require('underscore');
var uuid = require('node-uuid');

var ns = 'ice_rabbit_mq';

var kREPLY_WORKERS_EXCHANGE = 'REPLY_WORKERS_EXCHANGE';
var kWORKER_EXCHANGE = 'WORKER_EXCHANGE';

var kPASS_TO_OTHER_WORKER = {};

var module_inprocess_uuid = uuid.v1();

//-----------------------------------------------------------------------------
//TODO (Для скорости можно будет отказаться от использования promise на промежуточных вызовах)

var connection_promise = (function(){

  var deferred = q.defer();

  var connection = amqp.createConnection({ host: '127.0.0.1' });

  connection.on('ready', function(){
    deferred.resolve(connection);
  });

  return deferred.promise;
})();


//-----------------------------------------------------------------------------

var create_receive_queue = function(exchange_name, exchange_type, queue_name, queue_options, subscribe_options, subscribe_callback){
  return connection_promise.then(function(connection){
    var deferred = q.defer();
    
    var exchange = connection.exchange(exchange_name, {type: exchange_type, autoDelete:true});

    queue_name = queue_name || ns + '.queue_'+module_inprocess_uuid;

    var queue = connection.queue(queue_name, queue_options, function(){
      
      queue.bind(exchange, queue_name+'.*', function(){
        
        
        queue.subscribe(subscribe_options, function (message, headers, deliveryInfo, m) {
          subscribe_callback(queue, message, headers, deliveryInfo, m);
        })
        .addCallback(function(ok) {
          deferred.resolve([ok, queue]);
        });

      });
    });

    return deferred.promise;
  });
};

//-----------------------------------------------------------------------------

var register_worker = (function(){
  
  var worker_dictionary = {};

  var reply_worker_exchange = connection_promise.then(function(connection){
    var deferred = q.defer();
    
    connection.exchange(kREPLY_WORKERS_EXCHANGE, {type: 'topic', autoDelete:true}, function(exchange){
      deferred.resolve(exchange);
    });
    
    return deferred.promise;
  });

  return function(name, p_options, callback){
    /*
    var args = Array.prototype.slice.call(arguments, 1);
    var callback = args.pop();
    */
    var options = {ack:true, prefetchCount:1};

    if(_.isFunction(p_options)){
      callback = p_options;
    } else {
      options = _.extend(options, p_options, {ack:true});
    }
    console.log(options);

    if(!(name in worker_dictionary)){
      worker_dictionary[name] = (function(){
        //создаем очередь для воркера, и оборачиваем колбэк нормально
        create_receive_queue( kWORKER_EXCHANGE, 'topic',
                              ns + '.' + name, {autoDelete:true}, options,
                              function(queue, message, headers, deliveryInfo, m){

          try{
            var call_result = callback.apply(null, message);
            if(call_result === kPASS_TO_OTHER_WORKER){
              m.reject(true);
            } else {
              q(call_result)
              .then(function(result){

                m.acknowledge();

                return reply_worker_exchange.then(function(exchange){
                  exchange.publish(deliveryInfo.replyTo, {data:result}, _.pick(deliveryInfo, 'correlationId'));
                });
                
              })
              .catch(function(error){
                console.error('worker error');
                console.error(error.stack);

                m.acknowledge();

                return reply_worker_exchange.then(function(exchange){
                  exchange.publish(deliveryInfo.replyTo, {error:'worker runned with errors'}, _.pick(deliveryInfo, 'correlationId'));
                });

              }).done();
            }
          }catch(error){
            console.error('worker error');
            console.error(error.stack);

            m.acknowledge();

            return reply_worker_exchange.then(function(exchange){
              exchange.publish(deliveryInfo.replyTo, {error:'worker runned with errors'}, _.pick(deliveryInfo, 'correlationId'));
            });
          }
        });
      })();
    } else {
      throw new Error('worker with same name are already registered');
    }
  };
})();



//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------




var call_worker = (function(){
  
  var call_dictionary = {};

  var call_handler_with_error = function(callback_uid, error){
    if(callback_uid in call_dictionary){
      var deferred = call_dictionary[callback_uid];
        deferred.reject(error);
        delete call_dictionary[callback_uid];
    }
  };

  var unique_inprocess_route_key = ns + '.route_key_' + module_inprocess_uuid;

  var receive_queue_promise = create_receive_queue(kREPLY_WORKERS_EXCHANGE, 'topic',
                                                  unique_inprocess_route_key,
                                                  {autoDelete:true}, {},
                                                  function(queue, message, headers, deliveryInfo){
    
    //console.log('0Got a message with routing key ', message, deliveryInfo);
    var callback_uid = deliveryInfo.correlationId;
    
    if(callback_uid in call_dictionary){
      var deferred = call_dictionary[callback_uid];
      
      if(message.error){

        deferred.reject(message.error);
      } else {
        deferred.resolve(message.data);
      }
      
      delete call_dictionary[callback_uid];
    }
  });

  var worker_exchange = connection_promise.then(function(connection){
    var deferred = q.defer();
    connection.exchange(kWORKER_EXCHANGE, {type: 'topic', autoDelete:true}, function(exchange){
      deferred.resolve(exchange);
    });
    return deferred.promise;
  })
  .then(function(exchange){
    
    exchange.on('basic-return', function(args) {
      console.error('basic-return', args);
      
      var uuid = args.routingKey.split('.').pop();
      var replyCode = args.replyCode;
      var replyText = args.replyText;

      var error = new Error({replyCode:replyCode, replyText:replyText});
      call_handler_with_error(uuid, error);
    });
    
    return receive_queue_promise.then(function(){
      return exchange;
    });
  });

  return function(name){
    var args = Array.prototype.slice.call(arguments, 1);
    
    return worker_exchange.then(function(exchange){
      var callback_uuid = uuid.v1();
      var deferred = q.defer();
      call_dictionary[callback_uuid] = deferred;
      /**
       * постфикс ключа '.'+callback_uuid такой потому что это единственный способ отработать ошибку,
       * что нет ни одного воркера и мессагу кидать тупо некуда  
       */
      exchange.publish(ns+'.'+name+'.'+callback_uuid, args, {mandatory:true, replyTo:unique_inprocess_route_key+'.reply', correlationId:callback_uuid});
      args = null;
      return deferred.promise;
    });
  };
})();


module.exports.register_worker = register_worker;
module.exports.call_worker = call_worker;
module.exports.kPASS_TO_OTHER_WORKER = kPASS_TO_OTHER_WORKER;

